To create a virtual environment - 
1- Go into the repositrty 
2- python -m venv venv
3- .\venv\scripts\activate

To download all requirements libraries -
pip install -r requirements.txt 

To get started with the project -
django-admin startproject cfehome

To run the project 
python manage.py runserver 8000

To create an app
python manage.py startapp api
Django projects are made of apps ‚Äî each app handles a specific piece of functionality
Inside your project directory, Django will create a folder called api/ with files
models.py ‚Üí define database models (e.g., User, Post, etc.)
views.py ‚Üí handle HTTP requests (return JSON, HTML, etc.)
urls.py (not auto-created, but you usually add it) ‚Üí define URL routes for this app
admin.py ‚Üí register models so they appear in Django‚Äôs admin panel
apps.py ‚Üí app configuration (Django uses it internally)
migrations/ ‚Üí auto-generated files that describe changes to your database schema


For each app, we create the models inside models.py. Now after create the models we made django know abou the model that need to be introduced for the database 
python manage.py makemigrations
python manage.py migrate -> this makes sure databse does actually change based on the model


üîπ What is the Django shell?
-python manage.py shell
The Django shell is just like the normal Python interactive shell, but with your Django project already loaded.
This runs a Python interpreter where:
- Django settings are loaded.
- Your apps and models are available.
- You can directly interact with your database and project code.
üîπ What it does
-Imports Django environment (settings, installed apps).
-Lets you test queries, models, functions, serializers, etc.
-Executes code inside the context of your Django project.

Django ORM 
- Django ORM (Object-Relational Mapper) is a powerful feature of the Django web framework that allows you to interact with a database
using Python code instead of writing raw SQL queries.
- Instead of thinking in terms of tables and SQL, you think in terms of Python classes and objects. Django then automatically translates
those Python instructions into database queries.
Key Concepts
1.Models
In Django, you define your database schema as Python classes (called models).
Each model maps to a database table, and each attribute of the model represents a column.
example : 
from django.db import models
class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=100)
    published_date = models.DateField()

Django ORM lets you use Pythonic queries instead of writing SQL:
# Insert data
Book.objects.create(title="1984", author="George Orwell", published_date="1949-06-08")
# Get all records
books = Book.objects.all()
# Filter
orwell_books = Book.objects.filter(author="George Orwell")
# Update
book = Book.objects.get(id=1)
book.title = "Animal Farm"
book.save()
# Delete
book.delete()



üîπ What are Django Forms?
A Form in Django is a Python class that maps to an HTML form.
It lets you:
-Define what fields you expect from the user.
-Validate the input automatically.
-Convert it into Python types (int, bool, datetime, etc.).

forms.py
from django import forms

class ContactForm(forms.Form):
    name = forms.CharField(max_length=100)
    email = forms.EmailField()
    message = forms.CharField()

Using form in view : 
from .forms import ContactForm

def contact_view(request):
    if request.method == "POST":
        form = ContactForm(request.POST)   # bind data from request
        if form.is_valid():
            # cleaned data is safe to use
            name = form.cleaned_data['name']
            email = form.cleaned_data['email']
            message = form.cleaned_data['message']
            print(name, email, message)
            # Do something (save to DB, send email, etc.)


Forms vs ModelForms
Form ‚Üí you define fields manually (like ContactForm).
ModelForm ‚Üí automatically builds a form from a Django model.
from django import forms
from .models import Student

class StudentForm(forms.ModelForm):
    class Meta:
        model = Student
        fields = ['name', 'age']   # or use "__all__"

üîπ form.data
This is the raw input data (usually from request.POST).
Always contains strings, straight from the user/browser, before validation.
Django doesn‚Äôt modify it.
Example:
form = ContactForm({"name": "Ali", "age": "20"})
print(form.data)  
# {'name': 'Ali', 'age': '20'}   ‚Üê still a string!

üîπ form.cleaned_data
This is created only after you call form.is_valid().
Contains validated and type-converted values.
Only the fields that passed validation appear here.
Example:
if form.is_valid():
    print(form.cleaned_data)
    # {'name': 'Ali', 'age': 20}   ‚Üê int now, not string 

Another form.py example : 
# forms.py
from django import forms
from django.core.validators import MinLengthValidator

class ContactForm(forms.Form):
    name = forms.CharField(
        max_length=100,
        validators=[MinLengthValidator(2)],
    )
    email = forms.EmailField()
    message = forms.CharField(
        max_length=1000,
        strip=True,              # trims leading/trailing spaces
    )
    agree = forms.BooleanField(required=True)  # must be checked/True

    # Field-level validation
    def clean_name(self):
        name = self.cleaned_data["name"].strip()
        if any(char.isdigit() for char in name):
            raise forms.ValidationError("Name cannot contain numbers.")
        return name

    # Object-level (cross-field) validation
    def clean(self):
        cleaned = super().clean()
        email = cleaned.get("email")
        message = cleaned.get("message")

        if email and email.endswith("@example.com"):
            raise forms.ValidationError("Please use a non-example email domain.")

        if message and len(message.split()) < 3:
            self.add_error("message", "Message is too short ‚Äî add more details.")
        return cleaned


# Optional: ModelForm example (still backend-only)
# Validates according to your model + extra rules you add here.
from .models import Student

class StudentForm(forms.ModelForm):
    class Meta:
        model = Student
        fields = ["name", "age"]

    def clean_age(self):
        age = self.cleaned_data["age"]
        if age < 0:
            raise forms.ValidationError("Age cannot be negative.")
        return age

#serializers

Now let say we add a property discount to our model product, 
now if we do something like product.objects.first().sale_price -> in this case we will get our sale price for the product, however if we want that sale price when we make a get 
request for the product, so for this let say we add the sale_price as field to the model_to_dict, then we will not get the sale price
this is because sale_price is a computed property and model_to_dict() will not include it.
so for this, we have to manually add this property.


Instance method vs property 
An instance method is just a normal method defined on your model class.
-It requires you to call it with parantheses.
-Can take arguments (other than self).
-Can run any arbitrary logic.
A property lets you expose a method‚Äôs return value as if it were an attribute.
-No parentheses when accessing.
-Cannot take arguments (other than self).
-Makes computed values ‚Äúlook like‚Äù fields.


In Django REST Framework (DRF), a serializer is the component that helps convert between complex Python objects (like Django models) 
and primitive types (like dicts, lists, JSON).
üîπ What a Serializer Does
- Serialization (Python ‚Üí JSON)
Converts Django model instances or querysets into Python primitives (dicts, lists), which can then be rendered into JSON
-Serializers include validation methods to enforce rules on incoming data (like form validation in Django).
-Deserialization (JSON ‚Üí Python / DB)
Takes JSON (or other primitive data) and converts it into complex Python objects (usually model instances). Also validates that the input data is correct.
Example : 
data = {'title': '1984', 'author': 'George Orwell', 'published_date': '1949-06-08'}
serializer = BookSerializer(data=data)

if serializer.is_valid():
    book = serializer.save()   # creates a new Book instance
    print(book.id)
else:
    print(serializer.errors)

When serializer.save() Saves to DB
If you used the serializer with data=... (i.e. deserialization mode), and after calling .is_valid(), then .save() will either:
Create a new object if no instance was passed, or
Update an existing object if an instance was passed.
If you wrote a custom serializer (not a ModelSerializer) and didn‚Äôt implement create()/update(), then .save() won‚Äôt know how to persist ‚Äî you‚Äôd have to define that.